"""
Leonardo AI Service - Image Generation, Background Removal, Image-to-Video
With Redis caching for generated results

Background Removal: Uses rembg library (local processing) instead of Leonardo API
because Leonardo's nobg API only works with images generated by Leonardo,
not uploaded images.
"""
import httpx
import asyncio
import hashlib
import json
import io
import base64
from typing import Optional, Dict, Any, List
from datetime import timedelta
import redis.asyncio as redis
from PIL import Image
from rembg import remove as rembg_remove
from app.core.config import settings
import logging

logger = logging.getLogger(__name__)

LEONARDO_BASE_URL = "https://cloud.leonardo.ai/api/rest/v1"


class LeonardoService:
    def __init__(self):
        self.api_key = settings.LEONARDO_API_KEY
        self.redis: Optional[redis.Redis] = None
        self.cache_ttl = timedelta(hours=24)  # Cache results for 24 hours

    async def init_redis(self):
        """Initialize Redis connection"""
        if not self.redis:
            self.redis = redis.from_url(
                settings.REDIS_URL,
                encoding="utf-8",
                decode_responses=True
            )

    def _get_headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

    def _cache_key(self, prefix: str, params: Dict) -> str:
        """Generate cache key from parameters"""
        param_str = json.dumps(params, sort_keys=True)
        hash_val = hashlib.md5(param_str.encode()).hexdigest()
        return f"leonardo:{prefix}:{hash_val}"

    async def _get_cached(self, key: str) -> Optional[Dict]:
        """Get cached result"""
        if not self.redis:
            await self.init_redis()
        try:
            cached = await self.redis.get(key)
            if cached:
                logger.info(f"Cache hit for {key}")
                return json.loads(cached)
        except Exception as e:
            logger.error(f"Cache get error: {e}")
        return None

    async def _set_cached(self, key: str, value: Dict):
        """Set cached result"""
        if not self.redis:
            await self.init_redis()
        try:
            await self.redis.setex(
                key,
                int(self.cache_ttl.total_seconds()),
                json.dumps(value)
            )
            logger.info(f"Cached result for {key}")
        except Exception as e:
            logger.error(f"Cache set error: {e}")

    async def get_user_info(self) -> Dict:
        """Get user account info"""
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{LEONARDO_BASE_URL}/me",
                headers=self._get_headers()
            )
            response.raise_for_status()
            return response.json()

    async def generate_image(
        self,
        prompt: str,
        negative_prompt: str = "",
        width: int = 1024,
        height: int = 1024,
        num_images: int = 1,
        model_id: str = "b24e16ff-06e3-43eb-8d33-4416c2d75876",  # Leonardo Kino XL
        use_cache: bool = True
    ) -> Dict:
        """
        Generate image from text prompt

        Models:
        - b24e16ff-06e3-43eb-8d33-4416c2d75876: Leonardo Kino XL (photorealistic)
        - 6bef9f1b-29cb-40c7-b9df-32b51c1f67d3: Leonardo Diffusion XL
        - aa77f04e-3eec-4034-9c07-d0f619684628: Leonardo Vision XL
        """
        params = {
            "prompt": prompt,
            "negative_prompt": negative_prompt,
            "width": width,
            "height": height,
            "num_images": num_images,
            "modelId": model_id
        }

        # Check cache
        if use_cache:
            cache_key = self._cache_key("generate", params)
            cached = await self._get_cached(cache_key)
            if cached:
                return cached

        async with httpx.AsyncClient(timeout=120.0) as client:
            # Create generation
            response = await client.post(
                f"{LEONARDO_BASE_URL}/generations",
                headers=self._get_headers(),
                json={
                    "prompt": prompt,
                    "negative_prompt": negative_prompt,
                    "width": width,
                    "height": height,
                    "num_images": num_images,
                    "modelId": model_id,
                    "presetStyle": "CINEMATIC",
                    "public": False,
                    "promptMagic": True
                }
            )
            response.raise_for_status()
            data = response.json()
            generation_id = data["sdGenerationJob"]["generationId"]

            # Poll for results
            result = await self._poll_generation(client, generation_id)

            # Cache result
            if use_cache and result:
                await self._set_cached(cache_key, result)

            return result

    async def _poll_generation(
        self,
        client: httpx.AsyncClient,
        generation_id: str,
        max_attempts: int = 60,
        interval: float = 2.0
    ) -> Dict:
        """Poll for generation completion"""
        for _ in range(max_attempts):
            response = await client.get(
                f"{LEONARDO_BASE_URL}/generations/{generation_id}",
                headers=self._get_headers()
            )
            response.raise_for_status()
            data = response.json()

            generation = data.get("generations_by_pk", {})
            status = generation.get("status")

            if status == "COMPLETE":
                images = generation.get("generated_images", [])
                return {
                    "success": True,
                    "generation_id": generation_id,
                    "images": [
                        {
                            "id": img.get("id"),
                            "url": img.get("url"),
                            "nsfw": img.get("nsfw", False)
                        }
                        for img in images
                    ]
                }
            elif status == "FAILED":
                return {"success": False, "error": "Generation failed"}

            await asyncio.sleep(interval)

        return {"success": False, "error": "Generation timeout"}

    async def remove_background(
        self,
        image_url: str,
        use_cache: bool = True
    ) -> Dict:
        """
        Remove background from image using rembg library.

        Note: Leonardo's nobg API only works with images generated by Leonardo,
        not uploaded images. We use rembg (local processing) instead.

        Returns:
            Dict with success, image_url (data URL with base64) or error
        """
        params = {"image_url": image_url, "action": "remove_bg"}

        if use_cache:
            cache_key = self._cache_key("remove_bg", params)
            cached = await self._get_cached(cache_key)
            if cached:
                return cached

        try:
            async with httpx.AsyncClient(timeout=60.0) as client:
                # Download the image
                logger.info(f"Downloading image for bg removal: {image_url}")
                response = await client.get(image_url, follow_redirects=True)
                response.raise_for_status()
                image_data = response.content
                logger.info(f"Downloaded image: {len(image_data)} bytes")

            # Process with rembg (runs in thread pool to not block async)
            loop = asyncio.get_event_loop()
            result_image = await loop.run_in_executor(
                None,
                self._remove_bg_sync,
                image_data
            )

            if result_image:
                # Convert to base64 data URL for frontend
                buffered = io.BytesIO()
                result_image.save(buffered, format="PNG")
                img_base64 = base64.b64encode(buffered.getvalue()).decode()
                image_data_url = f"data:image/png;base64,{img_base64}"

                result = {
                    "success": True,
                    "image_url": image_data_url,
                    "format": "png"
                }

                if use_cache:
                    await self._set_cached(cache_key, result)

                logger.info("Background removal completed successfully")
                return result
            else:
                return {"success": False, "error": "Failed to process image"}

        except httpx.HTTPError as e:
            logger.error(f"Failed to download image: {e}")
            return {"success": False, "error": f"Failed to download image: {str(e)}"}
        except Exception as e:
            logger.error(f"Background removal error: {e}")
            return {"success": False, "error": str(e)}

    def _remove_bg_sync(self, image_data: bytes) -> Optional[Image.Image]:
        """
        Synchronous background removal using rembg.
        Called from executor to not block async loop.
        """
        try:
            # Open image from bytes
            input_image = Image.open(io.BytesIO(image_data))

            # Remove background using rembg
            output_image = rembg_remove(input_image)

            return output_image
        except Exception as e:
            logger.error(f"rembg processing error: {e}")
            return None

    async def _poll_nobg(
        self,
        client: httpx.AsyncClient,
        job_id: str,
        max_attempts: int = 60,
        interval: float = 2.0
    ) -> Dict:
        """Poll for no-background job completion"""
        for _ in range(max_attempts):
            response = await client.get(
                f"{LEONARDO_BASE_URL}/variations/{job_id}",
                headers=self._get_headers()
            )
            response.raise_for_status()
            data = response.json()

            # Check for nobg result
            variations = data.get("generated_image_variation_generic", [])
            if variations:
                variation = variations[0]
                status = variation.get("status")

                if status == "COMPLETE":
                    return {
                        "success": True,
                        "image_url": variation.get("url"),
                        "id": variation.get("id")
                    }
                elif status == "FAILED":
                    return {"success": False, "error": "Background removal failed"}

            await asyncio.sleep(interval)

        return {"success": False, "error": "Background removal timeout"}

    async def _upload_image_from_url(
        self,
        client: httpx.AsyncClient,
        image_url: str
    ) -> str:
        """Upload image from URL and return init image ID"""
        # Get presigned URL from Leonardo
        response = await client.post(
            f"{LEONARDO_BASE_URL}/init-image",
            headers=self._get_headers(),
            json={"extension": "jpg"}
        )
        response.raise_for_status()
        data = response.json()
        logger.info(f"Got presigned URL response: {data}")

        upload_url = data["uploadInitImage"]["url"]
        fields = data["uploadInitImage"]["fields"]
        init_image_id = data["uploadInitImage"]["id"]

        # Handle fields - might be string (JSON) or dict
        if isinstance(fields, str):
            import json as json_module
            form_data = json_module.loads(fields)
        else:
            form_data = dict(fields) if fields else {}

        logger.info(f"Upload fields: {form_data}")

        # Download image from source URL
        logger.info(f"Downloading image from: {image_url}")
        img_response = await client.get(image_url, follow_redirects=True)
        img_response.raise_for_status()
        image_data = img_response.content
        logger.info(f"Downloaded image: {len(image_data)} bytes")

        # Upload to presigned S3 URL
        files = {"file": ("image.jpg", image_data, "image/jpeg")}

        logger.info(f"Uploading to S3: {upload_url}")
        upload_response = await client.post(
            upload_url,
            data=form_data,
            files=files
        )

        # Check upload success (S3 returns 204 on success)
        if upload_response.status_code not in [200, 201, 204]:
            logger.error(f"S3 upload failed: {upload_response.status_code} - {upload_response.text}")
            raise Exception(f"Failed to upload image to S3: {upload_response.status_code}")

        logger.info(f"Image uploaded successfully, init_image_id: {init_image_id}")
        return init_image_id

    async def _poll_variation(
        self,
        client: httpx.AsyncClient,
        variation_id: str,
        max_attempts: int = 60,
        interval: float = 2.0
    ) -> Dict:
        """Poll for variation completion"""
        for _ in range(max_attempts):
            response = await client.get(
                f"{LEONARDO_BASE_URL}/variations/{variation_id}",
                headers=self._get_headers()
            )
            response.raise_for_status()
            data = response.json()

            variation = data.get("generated_image_variation_generic", [{}])[0]
            status = variation.get("status")

            if status == "COMPLETE":
                return {
                    "success": True,
                    "image_url": variation.get("url"),
                    "id": variation.get("id")
                }
            elif status == "FAILED":
                return {"success": False, "error": "Processing failed"}

            await asyncio.sleep(interval)

        return {"success": False, "error": "Processing timeout"}

    async def image_to_video(
        self,
        image_url: str,
        motion_strength: int = 5,
        use_cache: bool = True
    ) -> Dict:
        """
        Convert image to video using Leonardo Motion
        motion_strength: 1-10 (higher = more motion)
        """
        params = {
            "image_url": image_url,
            "motion_strength": motion_strength,
            "action": "image_to_video"
        }

        if use_cache:
            cache_key = self._cache_key("i2v", params)
            cached = await self._get_cached(cache_key)
            if cached:
                return cached

        async with httpx.AsyncClient(timeout=300.0) as client:
            # Upload image
            init_image_id = await self._upload_image_from_url(client, image_url)

            # Create motion generation
            response = await client.post(
                f"{LEONARDO_BASE_URL}/generations-motion-svd",
                headers=self._get_headers(),
                json={
                    "imageId": init_image_id,
                    "motionStrength": motion_strength,
                    "isPublic": False
                }
            )
            response.raise_for_status()
            data = response.json()

            generation_id = data.get("motionSvdGenerationJob", {}).get("generationId")
            if generation_id:
                result = await self._poll_motion(client, generation_id)
                if use_cache and result.get("success"):
                    await self._set_cached(cache_key, result)
                return result

            return {"success": False, "error": "Failed to start video generation"}

    async def _poll_motion(
        self,
        client: httpx.AsyncClient,
        generation_id: str,
        max_attempts: int = 120,
        interval: float = 3.0
    ) -> Dict:
        """Poll for motion generation completion"""
        for _ in range(max_attempts):
            response = await client.get(
                f"{LEONARDO_BASE_URL}/generations/{generation_id}",
                headers=self._get_headers()
            )
            response.raise_for_status()
            data = response.json()

            generation = data.get("generations_by_pk", {})
            status = generation.get("status")

            if status == "COMPLETE":
                images = generation.get("generated_images", [])
                if images:
                    return {
                        "success": True,
                        "generation_id": generation_id,
                        "video_url": images[0].get("motionMP4URL"),
                        "thumbnail_url": images[0].get("url")
                    }
            elif status == "FAILED":
                return {"success": False, "error": "Video generation failed"}

            await asyncio.sleep(interval)

        return {"success": False, "error": "Video generation timeout"}

    async def generate_product_scene(
        self,
        product_image_url: str,
        scene_prompt: str,
        use_cache: bool = True
    ) -> Dict:
        """
        Generate product in a new scene/background
        Uses img2img with the product as reference

        Note: init_strength controls how much of the ORIGINAL image to keep
        - Higher value (0.7-0.9) = keep more of original product
        - Lower value (0.1-0.3) = generate more new content
        """
        params = {
            "product_image_url": product_image_url,
            "scene_prompt": scene_prompt,
            "action": "product_scene"
        }

        if use_cache:
            cache_key = self._cache_key("product_scene", params)
            cached = await self._get_cached(cache_key)
            if cached:
                return cached

        async with httpx.AsyncClient(timeout=120.0) as client:
            # Upload product image
            init_image_id = await self._upload_image_from_url(client, product_image_url)

            # Generate with image reference - keep 75% of original product visible
            # Prompt focuses on the BACKGROUND/SCENE, not the product itself
            response = await client.post(
                f"{LEONARDO_BASE_URL}/generations",
                headers=self._get_headers(),
                json={
                    "prompt": f"Product placed in {scene_prompt}, professional product photography, the exact same product in center, beautiful background scene, studio lighting, high quality, commercial advertisement",
                    "negative_prompt": "different product, wrong product, blurry product, distorted product, low quality, watermark, text, changed product shape",
                    "width": 1024,
                    "height": 1024,
                    "num_images": 1,
                    "modelId": "b24e16ff-06e3-43eb-8d33-4416c2d75876",  # Kino XL
                    "init_image_id": init_image_id,
                    "init_strength": 0.75,  # FIXED: Keep 75% of original product
                    "presetStyle": "CINEMATIC",
                    "public": False
                }
            )
            response.raise_for_status()
            data = response.json()
            generation_id = data["sdGenerationJob"]["generationId"]

            result = await self._poll_generation(client, generation_id)

            if use_cache and result.get("success"):
                await self._set_cached(cache_key, result)

            return result

    async def generate_pattern(
        self,
        prompt: str,
        style: str = "seamless",
        use_cache: bool = True
    ) -> Dict:
        """
        Generate pattern/texture design

        Styles:
        - seamless: Tileable seamless patterns
        - floral: Flower and botanical patterns (花卉圖案)
        - geometric: Geometric shapes and modern patterns (幾何圖案)
        - abstract: Abstract artistic patterns
        - traditional: Traditional/cultural motifs
        """
        # Detailed style prompts for accurate pattern/design generation
        style_prompts = {
            "seamless": "seamless tileable pattern design, perfectly repeating, continuous pattern, textile design",
            "floral": "floral pattern design with flowers, botanical illustration, flower arrangement pattern, rose peony cherry blossom, nature inspired textile pattern",
            "geometric": "geometric pattern design, precise shapes, triangles circles squares, modern minimalist pattern, mathematical symmetry, architectural pattern",
            "abstract": "abstract artistic pattern, creative texture design, modern art inspired, unique visual pattern",
            "traditional": "traditional ornamental pattern, cultural motifs, classic decorative design, heritage pattern",
            "3d": "3D rendered design, three-dimensional illustration, 3D modeling, realistic 3D graphics, photorealistic render, high quality 3D visualization",
            "interior": "interior design visualization, room design, modern interior, architectural interior rendering, home decor design, professional interior photography style",
            "mockup": "product mockup design, product placement, professional product photography, commercial product display, e-commerce product visualization, product showcase"
        }

        # Build comprehensive prompt based on style type
        style_desc = style_prompts.get(style, style_prompts['seamless'])

        # For 3D/interior/mockup styles, don't add pattern-specific keywords
        if style in ['3d', 'interior', 'mockup']:
            full_prompt = f"{prompt}, {style_desc}, high resolution, professional quality, detailed"
        else:
            full_prompt = f"{prompt}, {style_desc}, pattern design, repeating motif, high resolution, professional textile design, vector-like quality"

        params = {
            "prompt": full_prompt,
            "style": style,
            "action": "pattern"
        }

        if use_cache:
            cache_key = self._cache_key("pattern", params)
            cached = await self._get_cached(cache_key)
            if cached:
                return cached

        # Use Leonardo Diffusion XL which is better for artistic/pattern generation
        result = await self.generate_image(
            prompt=full_prompt,
            negative_prompt="blurry, low quality, asymmetric, broken pattern, incomplete design, random noise, realistic photo, human faces, animals",
            width=1024,
            height=1024,
            num_images=1,
            model_id="6bef9f1b-29cb-40c7-b9df-32b51c1f67d3",  # Leonardo Diffusion XL - better for artistic
            use_cache=False  # We handle caching here
        )

        if use_cache and result.get("success"):
            await self._set_cached(cache_key, result)

        return result


# Singleton instance
leonardo_service = LeonardoService()
